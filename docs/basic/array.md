# Attack on Algorithm - 数组 🐝 

## 定义

**数组 :** 一种线性表数据结构 , 它使用一组连续的内存空间 , 来存储一组具有相同类型 (分语言) 的数据

存储相同类型有两个原因 : 

1. 相同的类型大小是固定且连续的 , 这样数组就可以通过索引随机访问了 , 因为同字节大小可以计算索引
2. 强类型语言要求指定数组中的元素类型

**线性表 :** 线性表就是所有数据元素排成像一条线一样的结构 , 线性表上的数据元素都是相同类型 , 且每个数据元素最多只有前、后两个方向 , 除数组外 , 栈、队列、链表都是线性表结构

**连续的内存空间 :** 线性表有两种存储结构 , 顺序存储结构和链式存储结构 ; 其中 , 顺序存储结构是指的占用的内存空间是连续的 , 相邻数据元素之间 , 物理内存上的存储位置也是相邻的 , 数组就是采用了顺序存储结构

**多维数组 :** 多维数组是一种扩展了的数组形式 , 它允许存储具有多个维度的数据 , 具体来说 , 多维数组是由多个索引组成的数组 , 每个索引对应一个维度

## 操作

### 读取元素

读取数组中的元素 , 是通过访问索引的方式来读取的 , 索引一般从 `0` 开始

在计算机中 , 内存可以看成一些已经排列好的格子 , 每个格子对应一个内存地址 , 一般情况下 , 数据会分散地存储在不同的格子中

![array-01](https://github.com/attack-on-backend/algorithm/blob/master/assert/array-01.png?raw=true)

而对于数组 , 计算机会在内存中为其申请一段 连续 的空间 , 并且会记下索引为 `0` 处的内存地址 , 以数组`["C", "O", "D", "E", "R"]` 为例 , 它的各元素对应的索引及内存地址如下图所示

![array-02](https://github.com/attack-on-backend/algorithm/blob/master/assert/array-02.png?raw=true)

假如我们想要访问索引为 `2` 处的元素 `"D"` 时 , 计算机会进行以下计算 : 

- 找到该数组的索引 `0` 的内存地址： 2008
- 将内存地址加上索引值 , 作为目标元素的地址 , 即 `2008 + 2 = 2010` , 对应的元素为 `"D"` , 这时便找到了目标元素

我们知道 , 计算内存地址这个过程是很快的 , 而我们一旦知道了内存地址就可以立即访问到该元素 , 因此它的时间复杂度是常数级别 , 为 `O(N)`

### 查找元素

与读取元素类似 , 由于我们只保存了索引为 `0` 处的内存地址 , 因此在查找元素时 , 只需从数组开头逐步向后查找就可以了 , 如果数组中的某个元素为目标元素 , 则停止查找 , 否则继续搜索直到到达数组的末尾

![array-03](https://github.com/attack-on-backend/algorithm/blob/master/assert/array-03.gif?raw=true)

我们发现 , 最坏情况下 , 搜索的元素为 `"R"` , 或者数组中不包含目标元素时 , 我们需要查找 `n` 次 , `n` 为数组的长度，因此查找元素的时间复杂度为 `O(N)` , `N`为数组长度

### 插入元素

如果要将该元素插入到数组的末尾 , 只需要一步 , 即计算机通过数组的长度和位置计算出即将插入元素的内存地址 , 然后将该元素插入到指定位置即可

![array-04](https://github.com/attack-on-backend/algorithm/blob/master/assert/array-04.gif?raw=true)



然而 , 如果要将该元素插入到数组中的其他位置 , 则会有所区别 , 这时我们首先需要为该元素所要插入的位置腾出 空间 , 然后进行插入操作 , 比如 , 我们想要在索引 `2` 处插入 `"S"`

![array-05](https://github.com/attack-on-backend/algorithm/blob/master/assert/array-05.gif?raw=true)

### 删除元素

删除元素与插入元素的操作类似 , 当我们删除掉数组中的某个元素后 , 数组中会留下 空缺 的位置 , 而数组中的元素在内存中是连续的 , 这就使得后面的元素需对该位置进行填补操作

以删除索引 `1` 中的元素 `"O"` 为例 , 具体过程如图所示

![array-06](https://github.com/attack-on-backend/algorithm/blob/master/assert/array-06.gif?raw=true)

当数组的长度为 `n` 时 , 最坏情况下 , 我们删除第一个元素 , 共需要的步骤数为 `1 + (n - 1) = n` 步 , 其中，`1` 为删除操作 , `n - 1` 为移动其余元素的步骤数 , 删除操作具有线性时间复杂度 , 即时间复杂度为 `O(N)` , `N`为数组的长度

## 例题

- [66. 加一](https://leetcode-cn.com/problems/plus-one)
- [941. 有效的山脉数组](https://leetcode-cn.com/problems/valid-mountain-array)
- [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array)
