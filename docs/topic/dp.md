# Attack on Algorithm - 动态规划 🐝 

## 定义

**动态规划 (Dynamic Programming) :** 简称 **DP** , 是一种求解多阶段决策过程最优化问题的方法 , 在动态规划中 , 通过把原问题分解为相对简单的子问题 , 先求解子问题 , 再由子问题的解而得到原问题的解

**动态规划的核心思想 :**

1. 把原问题分解为若干个**重叠**的子问题 , 每个子问题的求解过程都构成一个阶段 , 在完成一个阶段的计算之后 , 动态规划方法才会执行下一个阶段的计算
2. 在求解子问题的过程中 , 按照自顶向下的记忆化搜索方法或者自底向上的递推方法求解出子问题的解 , 把结果存储在表格中 , 当需要再次求解此子问题时 , 直接从表格中查询该子问题的解 , 从而避免了大量的重复计算

动态规划与分治算法的不同点在于 : 

1. 适用于动态规划求解的问题 , 在分解之后得到的子问题往往是相互联系的 , 会出现若干个重叠子问题
2. 使用动态规划方法会将这些重叠子问题的解保存到表格里 , 供随后的计算查询使用 , 从而避免大量的重复计算

能够使用动态规划方法解决的问题必须满足以下三个特征：

1. **最优子结构性质**
2. **重叠子问题性质**
3. **无后效性**

#### 最右子结构性质

举个例子 , 如下图所示 , 原问题 $S=\{a_1,a_2,a_3,a_4\}$ , 在 $a_1$ 步我们通过贪心选择选出一个当前最优解之后 , 问题就转换为求解子问题 $S_{子问题}=\{a_2,a_3,a_4\}$ , 如果原问题 $S$ 的最优解可以由第 $a_1$ 步通过贪心选择的局部最优解和$ S_{子问题}$ 的最优解构成 , 则说明该问题满足最优子结构性质

也就是说 , 如果原问题的最优解包含子问题的最优解 , 则说明该问题满足最优子结构性质

![dp-01](https://github.com/attack-on-backend/algorithm/blob/master/assert/dp-01.png?raw=true)

#### 重叠子问题性质

**重叠子问题性质 :** 指的是在求解子问题的过程中 , 有大量的子问题是重复的 , 一个子问题在下一阶段的决策中可能会被多次用到 , 如果有大量重复的子问题 , 那么只需要对其求解一次 , 然后用表格将结果存储下来 , 以后使用时可以直接查询 , 不需要再次求解

![dp-02](https://github.com/attack-on-backend/algorithm/blob/master/assert/dp-02.png?raw=true)

#### 无后效性

**无后效性 :** 指的是子问题的解 (状态值) 只与之前阶段有关 , 而与后面阶段无关 , 当前阶段的若干状态值一旦确定 , 就不再改变 , 不会再受到后续阶段决策的影响 , 也就是说 , 一旦某一个子问题的求解结果确定以后 , 就不会再被修改

## 方法

### 思想

如下图所示 , 我们在使用动态规划方法解决某些最优化问题时 , 可以将解决问题的过程按照一定顺序 (时间顺序、空间顺序或其他顺序) 分解为若干个相互联系的阶段 , 然后按照顺序对每一个阶段做出决策 , 这个决策既决定了本阶段的效益 , 也决定了下一阶段的初始状态 , 依次做完每个阶段的决策之后 , 就得到了一个整个问题的决策序列

这样就将一个原问题分解为了一系列的子问题 , 再通过逐步求解从而获得最终结果

![dp-03](https://github.com/attack-on-backend/algorithm/blob/master/assert/dp-03.png?raw=true)

这种前后关联、具有链状结构的多阶段进行决策的问题也叫做多阶段决策问题

通常我们使用动态规划方法来解决问题的基本思路如下：

1. 划分阶段 : 将原问题按顺序 (时间顺序、空间顺序或其他顺序) 分解为若干个相互联系的阶段 , 划分后的阶段⼀定是有序或可排序的 , 否则问题⽆法求解
2. 定义状态 : 将和子问题相关的某些变量 (位置、数量、体积、空间等等) 作为一个状态表示出来 , 状态的选择要满⾜⽆后效性
3. 状态转移 :  根据上一阶段的状态和该状态下所能做出的决策 , 推导出下一阶段的状态 , 或者说根据相邻两个阶段各个状态之间的关系 , 确定决策 , 然后推导出状态间的相互转移方式 (即状态转移方程)
4. 初始条件和边界条件 : 根据问题描述、状态定义和状态转移方程 , 确定初始条件和边界条件
5. 最终结果 : 确定问题的求解目标 , 然后按照一定顺序求解每一个阶段的问题 , 最后根据状态转移方程的递推结果 , 确定最终结果

### 实现

记忆化搜索与递推都是动态规划的实现方式 , 但是两者之间有一些区别

**记忆化搜索 :** 自顶向下的解决问题 , 采用自然的递归方式编写过程 , 在过程中会保存每个子问题的解 (通常保存在一个数组或哈希表中) 来避免重复计算

- 优点 : 代码清晰易懂 , 可以有效的处理一些复杂的状态转移方程 , 有些状态转移方程是非常复杂的 , 使用记忆化搜索可以将复杂的状态转移方程拆分成多个子问题 , 通过递归调用来解决
- 缺点 : 可能会因为递归深度过大而导致栈溢出问题

**递推 :** 自底向上的解决问题 , 采用循环的方式编写过程 , 在过程中通过保存每个子问题的解 (通常保存在一个数组或哈希表中) 来避免重复计算

- 优点 : 避免了深度过大问题 , 不存在栈溢出问题 , 计算顺序比较明确 , 易于实现
- 缺点 : 无法处理一些复杂的状态转移方程 , 有些状态转移方程非常复杂 , 如果使用递推方法来计算 , 就会导致代码实现变得非常困难

适合使用记忆化搜索的场景 : 

1. 问题的状态转移方程比较复杂 , 递推关系不是很明确
2. 问题适合转换为递归形式 , 并且递归深度不会太深

适合使用递推的场景 :

1. 问题的状态转移方程比较简单 , 递归关系比较明确
2. 问题不太适合转换为递归形式 , 或者递归深度过大容易导致栈溢出

基本代码框架

```python
def dynamic_programming(problem_input):
    # 1. 定义状态数组 dp
    # 2. 初始化 base case
    # 3. 状态转移方程（递推公式）
    # 4. 返回最终结果
```

## 例题

- [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)
- [1137. 第 N 个泰波那契数](https://leetcode.cn/problems/n-th-tribonacci-number/)
- [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)
- [62. 不同路径](https://leetcode.cn/problems/unique-paths/)
- [494. 目标和](https://leetcode.cn/problems/target-sum/)
- [576. 出界的路径数](https://leetcode.cn/problems/out-of-boundary-paths/)