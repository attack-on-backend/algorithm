# Attack on Algorithm - 位运算 🐝

## 定义

**位运算 (Bit Operation) :** 在计算机内部 , 数是以二进制 (Binary) 的形式来进行存储 , 位运算就是直接对数的二进制进行计算操作 , 在程序中使用位运算进行操作 , 会大大提高程序的性能

## 二进制

**二进制数 (Binary) :** 由 0 和 1 两个数码来表示的数 , 二进制数中每一个 0 或每一个 1 都称为一个位 (Bit)

#### 二进制转十进制

二进制转十进制的方法是 : **按权展开法 (加权求和)**

在二进制中 , $01101010_2$ 可以看做 $(0 × 2^7) + (1 × 2^6) + (1 × 2^5) + (0 × 2^4) + (1 × 2^3) + (0 × 2^2) + (1 × 2^1) + (0 × 2^0)$

即 $0 + 64 + 32 + 0 + 8 + 0 + 2 + 0 = 106$

![bit-01](https://github.com/attack-on-backend/algorithm/blob/master/assert/bit-01.png?raw=true)

#### 十进制转二进制

十进制整数转二进制数的方法是 : **除二取余 , 逆序排列法**

十进制小数转二进制数的方法是 : **乘二取整 , 顺序排列法**

还是以 `106` 为例 : 

$106 ÷ 2 = 53 (余0)$

  $53 ÷ 2 = 26 (余1)$

  $26 ÷ 2 = 13 (余0)$

​    $13 ÷ 2 = 6 (余1)$

​      $6 ÷ 2 = 3 (余0)$

​      $3 ÷ 2 = 1 (余1)$

​      $1 ÷ 2 = 0 (余1)$

​      $0 ÷ 2 = 0 (余0)$

从下往上遍历每次计算的余数 , 依次是 0, 1, 1, 0, 1, 0, 1, 0, 即 $01101010_2$ 

## 位运算

为运算规则如下 : 

| 运算符 | 描述           | 规则                                                         | 特性                                                   |
| ------ | -------------- | ------------------------------------------------------------ | ------------------------------------------------------ |
| `&`    | 按位与运算符   | 只有对应的两个二进位都为 1 时 , 结果位才为 1                 | 用于保留某些位 , 清零其他位                            |
| \|     | 按位或运算符   | 只要对应的两个二进位有一个为 1 时 , 结果位就为 1             | 设置某些位为1 , 不影响其他位                           |
| `^`    | 按位异或运算符 | 对应的两个二进位相异时 , 结果位为 1 , 二进位相同时则结果位为 0 | 相同的数异或会变回原数 , 可用于"翻转"某些位            |
| `~`    | 取反运算符     | 对二进制数的每个二进位取反 , 使数字 1 变为 0 , 0 变为 1      | 所有位反转 , 在 Python 中返回的是补码形式              |
| `<<`   | 左移运算符     | 将二进制数的各个二进位全部左移若干位 , `<<` 右侧数字指定了移动位数 , 高位丢弃 , 低位补 0 | 相当于乘以 2 的幂次 , `x << n` 等价 $x * 2^n$          |
| `>>`   | 右移运算符     | 对二进制数的各个二进位全部右移若干位 , `>>` 右侧数字指定了移动位数 , 低位丢弃 , 高位补 0 | 相当于除以 2 的幂并向下取整 , `x >> n` 等价 $x // 2^n$ |

### 按位与

**按位与运算 (AND) :** 按位与运算符为 `&` , 其功能是对两个二进制数的每一个二进位进行与运算

**按位与运算规则 :** 只有对应的两个二进位都为 1 时 , 结果位才为 1

- `1 & 1 = 1`
- `1 & 0 = 0`
- `0 & 1 = 0`
- `0 & 0 = 0`

举个例子 , 对二进制数 $01111100_2$ 与 $00111110_2$ 进行按位与运算 , 结果为 $00111100_2$ , 如图所示 :

![bit-02](https://github.com/attack-on-backend/algorithm/blob/master/assert/bit-02.png?raw=true)

### 按位或

**按位或运算 (OR) : **按位或运算符为 `|` , 其功能对两个二进制数的每一个二进位进行或运算

**按位或运算规则 :** 只要对应的两个二进位有一个为 1 时 , 结果位就为 1

- `1 | 1 = 1`
- `1 | 0 = 1`
- `0 | 1 = 1`
- `0 | 0 = 0`

举个例子 , 对二进制数 $01001010_2$ 与 $01011011_2$ 进行按位或运算 , 结果为 $01011011_2$ , 如图所示 : 

![bit-03](https://github.com/attack-on-backend/algorithm/blob/master/assert/bit-03.png?raw=true)

### 按位异或

**按位异或运算 (XOR) :** 按位异或运算符为 `^` , 其功能是对两个二进制数的每一个二进位进行异或运算

**按位异或运算规则 :** 对应的两个二进位相异时 , 结果位为 1 , 二进位相同时则结果位为 0

- `0 ^ 0 = 0`
- `1 ^ 0 = 1`
- `0 ^ 1 = 1`
- `1 ^ 1 = 0`

举个例子 , 对二进制数 $01001010_2$ 与 $01000101_2$ 进行按位异或运算 , 结果为 $00001111_2$ , 如图所示 : 

![bit-04](https://github.com/attack-on-backend/algorithm/blob/master/assert/bit-04.png?raw=true)

### 按位取反

**取反运算 (NOT) :** 取反运算符为 `~` , 其功能是对一个二进制数的每一个二进位进行取反运算

**取反运算规则 :** 使数字 1 变为 0 , 0 变为 1

- `~0 = 1`
- `~1 = 0`

举个例子 , 对二进制数 $01101010_2$ 进行取反运算 , 结果如图所示 : 

![bit-05](https://github.com/attack-on-backend/algorithm/blob/master/assert/bit-05.png?raw=true)

### 左移

**左移运算 (SHL) :**  左移运算符为 `<<` , 其功能是对一个二进制数的各个二进位全部左移若干位 (高位丢弃 , 低位补 00)

举个例子 , 对二进制数 $01101010_2$ 进行左移 1 位运算 , 结果为 $11010100_2$ , 如图所示 : 

![bit-06](https://github.com/attack-on-backend/algorithm/blob/master/assert/bit-06.png?raw=true)

### 右移

**右移运算 (SHR) :**  右移运算符为 `>>` , 其功能是对一个二进制数的各个二进位全部右移若干位 (低位丢弃 , 高位补 0)

举个例子 , 对二进制数 $01101010_2$ 进行右移 1 位运算 , 结果为 $00110101_2$ , 如图所示 : 

![bit-07](https://github.com/attack-on-backend/algorithm/blob/master/assert/bit-07.png?raw=true)

## 应用

| 运算               | 等价表达式                                               |
| ------------------ | -------------------------------------------------------- |
| `x << n`           | $x * 2^n$                                                |
| `x >> n`           | $x // 2^n$                                               |
| `x^=y; y^=x; x^=y` | 两数交换                                                 |
| `x & 1`            | 判断奇偶 , `(x & 1) == 0` 为偶数 , `(x & 1) == 1` 为奇数 |
| `(x >> k) & 1`     | 获取第k位                                                |
| `x \| (1 << k)`    | 设置第k位为1                                             |
| `x & ~(1 << k)`    | 将第k位设置为0                                           |
| `x & (x - 1)`      | 将最右侧的1改成0 (循环这个操作课用来统计1的个数)         |
| `x & (x - 1) == 0` | 判断是否为2的幂次方                                      |
| `x & -x`           | 得到最低位的1 (树状数组lowbit)                           |
| `x ^ x`            | 快速置零                                                 |
| `x \| (x + 1)`     | 将最低位的0变成1                                         |

## 例题

- [191. 位1的个数](https://leetcode.cn/problems/number-of-1-bits/)
- [190. 颠倒二进制位](https://leetcode.cn/problems/reverse-bits/)
- [371. 两整数之和](https://leetcode.cn/problems/sum-of-two-integers/)