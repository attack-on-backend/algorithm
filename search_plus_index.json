{"./":{"url":"./","title":"介绍","keywords":"","body":"Attack on Algorithm 🐝 介绍 🐙 致力构建一个高质量的后端技术图谱 在线阅读 体验更丝滑哟 目录 🚀 基础篇 数组 栈 队列 链表 树 哈希表 双指针 进阶篇 前缀树 并查集 跳表 剪枝 图 堆 拓展篇 双端队列 优先队列 单调栈 线段树 树状数组 专题篇 二分法 位运算 排序 搜索 递归与回溯 字符串匹配 动态规划 分治 贪心 题解 66.加一 941.有效的山脉数组 189.旋转数组 "},"SUMMARY.html":{"url":"SUMMARY.html","title":"目录","keywords":"","body":"Attack on Algorithm 🐝 介绍 目录 基础篇 数组 栈 队列 链表 树 哈希表 双指针 进阶篇 前缀树 并查集 跳表 剪枝 图 堆 拓展篇 双端队列 优先队列 单调栈 线段树 树状数组 专题篇 二分法 位运算 排序 搜索 递归与回溯 字符串匹配 动态规划 分治 贪心 题解 逆波兰表达式求值 最小栈 旋转数组 有效的括号 合并两个有序链表 旋转链表 加一 删除排序链表中的重复元素 有效的山脉数组 "},"01-基础篇/":{"url":"01-基础篇/","title":"基础篇","keywords":"","body":"Attack on Algorithm - 基础篇 🐝 基础篇 数组 栈 队列 链表 树 哈希表 双指针 "},"01-基础篇/01-数组.html":{"url":"01-基础篇/01-数组.html","title":"数组","keywords":"","body":"Attack on Algorithm - 数组 🐝 讲义 leetcode - array-and-string 例题 66.加一 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1： 输入：digits = [1,2,3] 输出：[1,2,4] 解释：输入数组表示数字 123。 示例 2： 输入：digits = [4,3,2,1] 输出：[4,3,2,2] 解释：输入数组表示数字 4321。 示例 3： 输入：digits = [0] 输出：[1] 提示： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/plus-one 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 941.有效的山脉数组 给定一个整数数组 arr，如果它是有效的山脉数组就返回 true，否则返回 false。 让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组： arr.length >= 3 在 0 arr[i+1] > ... > arr[arr.length - 1] 示例 1： 输入：arr = [2,1] 输出：false 示例 2： 输入：arr = [3,5,5] 输出：false 示例 3： 输入：arr = [0,3,2,1] 输出：true 提示： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-mountain-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 189.旋转数组 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 进阶： 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 提示： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/rotate-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 "},"01-基础篇/02-栈.html":{"url":"01-基础篇/02-栈.html","title":"栈","keywords":"","body":"Attack on Algorithm - 栈 🐝 讲义 leetcode - queue-stack 例题 20.有效的括号 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 输入：s = \"()\" 输出：true 示例 2： 输入：s = \"()[]{}\" 输出：true 示例 3： 输入：s = \"(]\" 输出：false 示例 4： 输入：s = \"([)]\" 输出：false 示例 5： 输入：s = \"{[]}\" 输出：true 提示： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-parentheses 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 155.最小栈 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例: 输入： [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --> 返回 -3. minStack.pop(); minStack.top(); --> 返回 0. minStack.getMin(); --> 返回 -2. 提示： pop、top 和 getMin 操作总是在 非空栈 上调用。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/min-stack 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 150.逆波兰表达式求值 根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2： 输入：tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3： 输入：tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"] 输出：22 解释： 该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 提示： 1 tokens[i] 要么是一个算符（\"+\"、\"-\"、\"*\" 或 \"/\"），要么是一个在范围 [-200, 200] 内的整数 逆波兰表达式： 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 "},"01-基础篇/03-队列.html":{"url":"01-基础篇/03-队列.html","title":"队列","keywords":"","body":"Attack on Algorithm - 队列 🐝 讲义 leetcode - queue-stack "},"01-基础篇/04-链表.html":{"url":"01-基础篇/04-链表.html","title":"链表","keywords":"","body":"Attack on Algorithm - 链表 🐝 讲义 leetcode - linked-list "},"01-基础篇/05-树.html":{"url":"01-基础篇/05-树.html","title":"树","keywords":"","body":"Attack on Algorithm - 树 🐝 讲义 二叉树 : leetcode - binary-tree 二叉搜索树 : leetcode - binary-search-tree N叉树 : leetcode - n-ary-tree "},"01-基础篇/06-哈希表.html":{"url":"01-基础篇/06-哈希表.html","title":"哈希表","keywords":"","body":"Attack on Algorithm - 哈希表 🐝 讲义 leetcode - hash-table "},"01-基础篇/07-双指针.html":{"url":"01-基础篇/07-双指针.html","title":"双指针","keywords":"","body":""},"02-进阶篇/":{"url":"02-进阶篇/","title":"进阶篇","keywords":"","body":"Attack on Algorithm - 进阶篇 🐝 进阶篇 前缀树 并查集 跳表 剪枝 图 堆 "},"02-进阶篇/01-前缀树.html":{"url":"02-进阶篇/01-前缀树.html","title":"前缀树","keywords":"","body":""},"02-进阶篇/02-并查集.html":{"url":"02-进阶篇/02-并查集.html","title":"并查集","keywords":"","body":""},"02-进阶篇/03-跳表.html":{"url":"02-进阶篇/03-跳表.html","title":"跳表","keywords":"","body":""},"02-进阶篇/04-剪枝.html":{"url":"02-进阶篇/04-剪枝.html","title":"剪枝","keywords":"","body":""},"02-进阶篇/05-图.html":{"url":"02-进阶篇/05-图.html","title":"图","keywords":"","body":""},"02-进阶篇/06-堆.html":{"url":"02-进阶篇/06-堆.html","title":"堆","keywords":"","body":""},"03-拓展篇/":{"url":"03-拓展篇/","title":"拓展篇","keywords":"","body":"Attack on Algorithm - 拓展篇 🐝 拓展篇 双端队列 优先队列 单调栈 线段树 树状数组 "},"03-拓展篇/01-双端队列.html":{"url":"03-拓展篇/01-双端队列.html","title":"双端队列","keywords":"","body":""},"03-拓展篇/02-优先队列.html":{"url":"03-拓展篇/02-优先队列.html","title":"优先队列","keywords":"","body":""},"03-拓展篇/03-单调栈.html":{"url":"03-拓展篇/03-单调栈.html","title":"单调栈","keywords":"","body":""},"03-拓展篇/04-线段树.html":{"url":"03-拓展篇/04-线段树.html","title":"线段树","keywords":"","body":""},"03-拓展篇/05-树状数组.html":{"url":"03-拓展篇/05-树状数组.html","title":"树状数组","keywords":"","body":""},"04-专题篇/":{"url":"04-专题篇/","title":"专题篇","keywords":"","body":"Attack on Algorithm - 专题篇 🐝 专题篇 二分法 位运算 排序] 搜索 递归与回溯 字符串匹配 动态规划 分治 贪心 "},"04-专题篇/01-二分法.html":{"url":"04-专题篇/01-二分法.html","title":"二分法","keywords":"","body":""},"04-专题篇/02-位运算.html":{"url":"04-专题篇/02-位运算.html","title":"位运算","keywords":"","body":""},"04-专题篇/03-排序.html":{"url":"04-专题篇/03-排序.html","title":"排序","keywords":"","body":""},"04-专题篇/04-搜索.html":{"url":"04-专题篇/04-搜索.html","title":"搜索","keywords":"","body":""},"04-专题篇/05-递归与回溯.html":{"url":"04-专题篇/05-递归与回溯.html","title":"递归与回溯","keywords":"","body":""},"04-专题篇/06-字符串匹配.html":{"url":"04-专题篇/06-字符串匹配.html","title":"字符串匹配","keywords":"","body":""},"04-专题篇/07-动态规划.html":{"url":"04-专题篇/07-动态规划.html","title":"动态规划","keywords":"","body":""},"04-专题篇/08-分治.html":{"url":"04-专题篇/08-分治.html","title":"分治","keywords":"","body":""},"04-专题篇/09-贪心.html":{"url":"04-专题篇/09-贪心.html","title":"贪心","keywords":"","body":""},"05-题解/":{"url":"05-题解/","title":"题解","keywords":"","body":"Attack on Algorithm - 题解 🐝 题解 66.加一 941.有效的山脉数组 189.旋转数组 "},"05-题解/01-150.逆波兰表达式求值.html":{"url":"05-题解/01-150.逆波兰表达式求值.html","title":"逆波兰表达式求值","keywords":"","body":"150.逆波兰表达式求值 题目 根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2： 输入：tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3： 输入：tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"] 输出：22 解释： 该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 提示： 1 tokens[i] 要么是一个算符（\"+\"、\"-\"、\"*\" 或 \"/\"），要么是一个在范围 [-200, 200] 内的整数 逆波兰表达式： 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 平常使用的算式则是一种中缀表达式，如( 1 + 2 ) * ( 3 + 4 ) 。 该算式的逆波兰表达式写法为( ( 1 2 + ) ( 3 4 + ) * ) 。 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 思路一 - 栈 将数字推入栈中 , 遇到运算符就 pop 两次进行计算 , 将计算结果重新推入栈中 , 循环处理 class Solution: def evalRPN(self, tokens: List[str]) -> int: import operator _stack = [] opt_map = {'+': operator.add, '-': operator.sub, '*': operator.mul, '/':operator.truediv} for t in range(len(tokens)): if tokens[t] in opt_map: r, l = _stack.pop(), _stack.pop() _stack.append(int(opt_map[tokens[t]](l, r))) else: _stack.append(int(tokens[t])) return _stack.pop() 时间复杂度：$O(N)$ , N 为数组长度 空间复杂度：$O(N)$ "},"05-题解/01-155.最小栈.html":{"url":"05-题解/01-155.最小栈.html","title":"最小栈","keywords":"","body":"155.最小栈 题目 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例: 输入： [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --> 返回 -3. minStack.pop(); minStack.top(); --> 返回 0. minStack.getMin(); --> 返回 -2. 提示： pop、top 和 getMin 操作总是在 非空栈 上调用。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/min-stack 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 思路一 - 暴力解 使用 list 来模拟栈操作 class MinStack: def __init__(self): \"\"\" initialize your data structure here. \"\"\" self._stack = [] def push(self, x: int) -> None: self._stack.append(x) def pop(self) -> None: self._stack.pop() def top(self) -> int: return self._stack[-1] def getMin(self) -> int: min_num = self._stack[0] for i in range(1, len(self._stack)): if self._stack[i] 时间复杂度： push(x) : $O(1)$ pop() : $O(1)$ top() : $O(1)$ getMin() : $O(N)$ 思路二 - 优化 getMin() 基于思路一 , 将最小元素提前存储 , 在栈进行删除和新增的时候维护最小元素 class MinStack: def __init__(self): \"\"\" initialize your data structure here. \"\"\" self._stack = [] self.min = None def push(self, x: int) -> None: self._stack.append(x) if self.min is None or self.min > x: self.min = x def pop(self) -> None: x = self._stack.pop() if x == self.min: self.min = min(self._stack) if self._stack else None def top(self) -> int: return self._stack[-1] def getMin(self) -> int: return self.min 时间复杂度： push(x) : $O(1)$ pop() : $O(N)$ top() : $O(1)$ getMin() : $O(1)$ "},"05-题解/01-189.旋转数组.html":{"url":"05-题解/01-189.旋转数组.html","title":"旋转数组","keywords":"","body":"189.旋转数组 题目 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 进阶： 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 提示： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/rotate-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 思路一 - 切片拼接 以倒数第 k 位置为分界线 , 用切片切分出两个数组 , 再拼接两个数组 , 由于要求在原地操作所以最后再进行一下复制 (但是这样的话空间复杂度为 $O(N)$ 而不是 $O(1)$) 注意 : k 可能大于数组长度 class Solution: def rotate(self, nums: List[int], k: int) -> None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" nums[:] = nums[len(nums) - k % len(nums):] + nums[:len(nums) - k % len(nums)] 时间复杂度：$O(N)$ , N 为数组长度 空间复杂度：$O(N)$ 思路二 - 环形换位 向右移动 k 个位置 , 或者是向左移动 nums.length - k 个位置 向左换位 : 从尾部开始遍历 , 将第 i 个元素与第 i - nums.length - k 个元素互换 , 互换之前需要将被互换的位置的元素用变量存储起来再作为下一个换位的元素继续重复操作 , 整个换位过程刚好形成一个环 向右换位 : 从头部开始遍历 , 将第 i 个元素与第 i + k 个元素互换 , 互换之前同样需要将被互换的位置的元素用变量存储起来再作为下一个换位的元素继续重复操作 , 整个换位过程刚好形成一个环 注意 : k 可能大于数组长度 k % len(nums) == 0 表示数组不移动 换位过程中可能有多个环 , 所以如果没有遍历完 , 当下一个索引回到了开始索引时 , 就应该往后挪一位继续换位操作 # 以右移为例 class Solution: def rotate(self, nums, k) -> None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" if k % len(nums) == 0: return start, index, next_num = 0, 0, nums[0] for i in range(len(nums)): next_index = (index + k) % len(nums) next_num, nums[next_index] = nums[next_index], next_num index = next_index if next_index == start: index = start = start + 1 next_num = nums[index] 时间复杂度：$O(N)$ , N 为数组长度 空间复杂度：$O(1)$ 思路三 - 三次反转 向右移 k 个位置 , 就是把从 len(nums) - k 到 len(nums) -1 的这段数组 , 与从 0 到 len(nums) - k - 1 这段数组调换一下位置 , 那我们可以 : 先反转整个数组 , 使两段数组的位置正确 但是由于反转了整个数组 , 所以两段数组的位置顺序都被反转了 , 那么我们再分别反转这两段数组 class Solution: def rotate(self, nums, k) -> None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" self.reverse(0, len(nums) - 1, nums) self.reverse(0, k % len(nums) - 1, nums) self.reverse(k % len(nums), len(nums) - 1, nums) def reverse(self, start, end, nums): for i in range((end - start + 1) // 2): nums[start + i], nums[end - i] = nums[end - i], nums[start + i] 时间复杂度：$O(N)$ , N 为数组长度 空间复杂度：$O(1)$ "},"05-题解/01-20.有效的括号.html":{"url":"05-题解/01-20.有效的括号.html","title":"有效的括号","keywords":"","body":"20.有效的括号 题目 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 输入：s = \"()\" 输出：true 示例 2： 输入：s = \"()[]{}\" 输出：true 示例 3： 输入：s = \"(]\" 输出：false 示例 4： 输入：s = \"([)]\" 输出：false 示例 5： 输入：s = \"{[]}\" 输出：true 提示： 1 s 仅由括号 '()[]{}' 组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-parentheses 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 思路一 - 栈 先将括号入栈 , 遇到匹配的就出栈 , 最后栈为空 注意 : k 可能大于数组长度 class Solution: def isValid(self, s: str) -> bool: _stack = [] brackets = {'(': ')', '{': '}', '[': ']'} for i in s: if _stack: if brackets.get(_stack[-1], None) == i: _stack.pop() continue _stack.append(i) return False if _stack else True 时间复杂度：$O(N)$ , N 为数组长度 空间复杂度：$O(N)$ 思路二 - 字符串替换 左括号和又括号一定是对应的 , 所以我们可以直接替换 () , {} , [] 为空字符串 , 如果结果为空字符串就说明有效 注意 : 有可能存在嵌套的括号 , 所以要循环替换 class Solution: def isValid(self, s: str) -> bool: while '()' in s or '{}' in s or '[]' in s: s = s.replace('()', '').replace('{}', '').replace('[]', '') return False if s else True 时间复杂度：$O(N)$ , N 为数组长度 空间复杂度：$O(N)$ "},"05-题解/01-21.合并两个有序链表.html":{"url":"05-题解/01-21.合并两个有序链表.html","title":"合并两个有序链表","keywords":"","body":"21.合并两个有序链表 题目 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2： 输入：l1 = [], l2 = [] 输出：[] 示例 3： 输入：l1 = [], l2 = [0] 输出：[0] 提示： 两个链表的节点数目范围是 [0, 50] -100 l1 和 l2 均按 非递减顺序 排列 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/ 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 "},"05-题解/01-61.旋转链表.html":{"url":"05-题解/01-61.旋转链表.html","title":"旋转链表","keywords":"","body":"61.旋转链表 题目 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。 示例 1： 输入：head = [1,2,3,4,5], k = 2 输出：[4,5,1,2,3] 示例 2： 输入：head = [0,1,2], k = 4 输出：[2,0,1] 提示： 链表中节点的数目在范围 [0, 500] 内 -100 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/rotate-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 "},"05-题解/01-66.加一.html":{"url":"05-题解/01-66.加一.html","title":"加一","keywords":"","body":"66.加一 题目 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1： 输入：digits = [1,2,3] 输出：[1,2,4] 解释：输入数组表示数字 123。 示例 2： 输入：digits = [4,3,2,1] 输出：[4,3,2,2] 解释：输入数组表示数字 4321。 示例 3： 输入：digits = [0] 输出：[1] 提示： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/plus-one 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 思路一 - 反向遍历 反向遍历数组 , 遇 9 进 1 , 遇到不等于 9 就结束遍历 注意 : 如果没有被 break 打断 , 需要在数组前补一位 class Solution: def plusOne(self, digits: List[int]) -> List[int]: for i in range(len(digits)): if digits[~i] == 9: digits[~i] = 0 else: digits[~i] = digits[~i] + 1 break else: digits.insert(0, 1) return digits # 注: ~ 操作符为按位取反,就可以得到反向对称的索引 时间复杂度：$O(N)$ , N 为数组长度 空间复杂度：$O(1)$ 思路二 - 类型转换 数组转数字 , 加 1 操作后再打散成数组 , 不过这样做就脱离题意了 class Solution: def plusOne(self, digits: List[int]) -> List[int]: return [int(n) for n in str(int(''.join(list(map(lambda x: str(x), digits)))) + 1)] 时间复杂度：$O(N)$ , N 为数组长度 空间复杂度：$O(N)$ "},"05-题解/01-83.删除排序链表中的重复元素.html":{"url":"05-题解/01-83.删除排序链表中的重复元素.html","title":"删除排序链表中的重复元素","keywords":"","body":"83. 删除排序链表中的重复元素 题目 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。 返回同样按升序排列的结果链表。 示例 1： 输入：head = [1,1,2] 输出：[1,2] 示例 2： 输入：head = [1,1,2,3,3] 输出：[1,2,3] 提示： 链表中节点数目在范围 [0, 300] 内 -100 题目数据保证链表已经按升序排列 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 "},"05-题解/01-941.有效的山脉数组.html":{"url":"05-题解/01-941.有效的山脉数组.html","title":"有效的山脉数组","keywords":"","body":"941.有效的山脉数组 题目 给定一个整数数组 arr，如果它是有效的山脉数组就返回 true，否则返回 false。 让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组： arr.length >= 3 在 0 arr[i+1] > ... > arr[arr.length - 1] 示例 1： 输入：arr = [2,1] 输出：false 示例 2： 输入：arr = [3,5,5] 输出：false 示例 3： 输入：arr = [0,3,2,1] 输出：true 提示： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-mountain-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 思路一 - 标志判断 定义一个标志位 , 标志是处于上升阶段还是下降阶段 注意 : 标志位最终结果必须标志着下降才是有效的山脉数组 # flag = 0 标志着处于上升阶段 # flag = 1 标志着处于下降阶段 class Solution: def validMountainArray(self, arr: List[int]) -> bool: flag = 0 for i in range(len(arr) - 1): if arr[i] == arr[i + 1]: return False # 上升 if flag == 0: if arr[i] > arr[i + 1]: if i == 0: return False flag = 1 # 下降 else: if arr[i] 时间复杂度：$O(N)$ , N 为数组长度 空间复杂度：$O(1)$ 思路二 - 双指针 利用双指针 , 分别同时从左右两边进行遍历 , 当左右指针都开始下降时停止 , 如果此时左右指针相等则为有效山脉 , 否则无效 注意 : 结束循环时 , 左指针不能是第一个元素 , 右指针不能是最后一个元素 class Solution: def validMountainArray(self, A) -> bool: if len(A) 时间复杂度：$O(N)$ , N 为数组长度 空间复杂度：$O(1)$ "}}